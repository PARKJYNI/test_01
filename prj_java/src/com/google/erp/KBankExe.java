package com.google.erp;

//KBank 클래스를 객체화하고 메소드를 호출하는 [KBankExe] 클래스 선언.
public class KBankExe {

	//JVM이 가장 먼저 찾아 자동으로 호출하는 main 메소드 선언.
	public static void main(String[] args) {
		
		// KBank 클래스를 객체화해서 객체의 메위주를 bank에 집어넣음
		// 복붙4
		KBank bank = new KBank( 3000 );
		//KBank 객체의 메소드 호출하여원하는 작업하기
		System.out.println("현재 저금 총액 : " + bank.getMoney());
		bank.add(3000);
		System.out.println("현재 저금 총액 : " + bank.getMoney());
		bank.minus(2500);
		System.out.println("현재 저금 총액 : " + bank.getMoney());
		
	
		// 동일한 블럭 내에 동일한 이름의 변수 [선언]은 2개 이상 불가능함. 누구 쓸지 어케 알아;;
		// bank = new KBank( ); -> 갱신이기 때문에 에러 없음.
//		KBank bank2 = new KBank(5000);
//		System.out.println("현재 저금 총액2 : " + bank2.getMoney());
//		bank.add(700);
//		System.out.println("현재 저금 총액 : " + bank2.getMoney());
//		bank2.minus(1500);
//		System.out.println("현재 저금 총액 : " + bank2.getMoney());

		
		
		
		
		

		
		
		
		
		

/*
==========================
<문> import com.google.erp.KBank; 가 없어도 KBank 클래스가 수입되는 이유는?
<풀> 동일한 패키지의 타 클래스는 import 구문이 없어도 자동 수입된다.

import 구문이 없어도 자동 수입되는클래스
동일한 패키지의 타 클래스.
java.lang 패키지 안의 클래스

==========================

<문> KBank 클래스에서 public class KBank{ ~ } 를 class KBank{ ~ } 로 수정하면?
<풀> 클래스 앞에 public이 없으면 타 패키지의 타 클래스에서 import구문으로 수입하는 것을 막는다.
즉 , 타 패키지의 타 클래스에서 수입을 할 수 없다. 
현재 KBank 클래스 BankExe클래스는 동일한 패키지에 있으므로 클래스 앞에 public이 없어도 수입된다.

==========================

<문> KBank bank = new KBank( 3000 ); 를 KBank bank = new KBank(  ); 로 수정하면?(동료생성자 호출하는 코드 有)
<풀> 에러 없음.
KBank bank = new KBank( ); 에서
KBank( ) 는 생성자로서
KBank( ) 생성자를 가진 클래스를 찾아 객체화하고
이 생성자를 호출할 예정이다.
현재 수입된 클래스 중에 KBank( ) 호출을 감당할 클래스가 있다.
KBank 클래스이다.
	 
==========================

<문> KBank bank = new KBank( 3000 ); 를 KBank bank = new KBank( 3000.5 ); 로 수정하면?
<풀> 에러 발생.
KBank bank = new KBank( 3000.5 ); 에서
KBank( 3000.5 ) 는 생성자로서
KBank( 3000.5 ) 생성자를 가진 클래스를 찾아 객체화하고
이 생성자를 호출할 예정이다.
현재 수입된 클래스 중에 KBank( 3000.5 ) 호출을 감당할 클래스가 없다.

==========================

<문> bank.add( 3000 ) 를 bank.add( 3000.3 ) 로 수정하면?
<풀> 에러 발생.
KBank 클래스의  add 메소드는 public void add( int money ){~}  로 선언되어 있다.

3000.3 이 매개변수 int money 로 전달되는데 매개변수 자료형이 int 이다.
불가능한 일이다.

==========================

<문> KBank 클래스에서 public KBank( int money ){~} 를 

	 protected KBank( int money ){~} 

	    또는

	 KBank( int money ){~} 

	    또는

	 private KBank( int money ){~} 

		로 수정하면?
		
		
private 이 붙을 때만 에러 발생.
private 이 붙을 때 에러 발생 지점 => KBankExe 클래스 내부의 KBank bank = new KBank(3000);
(new에 의해 객체화할 때 찾을 수 없음)
private이 붙은 생성자는 타 클래스에서 new에 의해 객체화 할 때 찾을 수 없는 생성자가 된다. 그러므로 객체화가 불가능하다.
<주의> private이 붙은 생성자는 동료 생성자만이 호출 가능함.

==========================

<문> KBank 클래스에서 public void add( int money ){~} 를 

	 protected void add( int money ){~}

	    또는

	 void add( int money ){~}

	    또는

	 private void add( int money ){~}

		로 수정하면?
		
private 이 붙을 때만 에러 발생.
private 이 붙을 때 에러 발생 지점 => KBankExe 클래스 내부의 bank.add(3000) 부분;
private 이 붙은 메소드는 타 클래스에서 호출이 불가능함.(안보여~ 스텔스기~)
<주의> private 이 붙은 메소드는 동료 생성자/메소드/속성변수 만이 호출 가능함.

====================================================	

< protected >
접근제어자가 protected로 설정되었다면 protected가 붙은 변수, 메소드는 
동일 패키지 타 클래스 O 
타 패키지: 해당 클래스를 상속받은 다른 패키지의 클래스에서만 접근이 가능하다.
	
< default >	
해당 패키지 내에서만 접근 O 
 -> 동일 패키지 타 클래스 OK, 
 -> 타 패키지는: X	
	
	[Xx 클래스]와 [Yy 클래스] 가 서로 같은 패키지의 소속일 경우
	[Xx 클래스] 내부에서 new 에 의한 [Yy 클래스]의 생성자 찾기/호출하기.
	
							동일 a.b.c 패키지
				Xx 클래스					Yy 클래스
			----------------------     ----------------------
			~ 메소드(~){
				~ new Yy(~); --->		public Yy(~){~}		O
				~ new Yy(~); --->		protected Yy(~){~}	O
				~ new Yy(~); --->		[default] Yy(~){~}	O
				~ new Yy(~); --->		private Yy(~){~}	X
				
====================================================	

	[Xx 클래스]와 [Yy 클래스] 가 서로 다른 패키지의 소속일 경우
	[Xx 클래스] 내부에서 new 에 의한 [Yy 클래스]의 생성자 찾기/호출하기.
	
				a.b.c 패키지				d.e.f 패키지
				Xx 클래스				public이 붙은 Yy 클래스
			----------------------     ----------------------
			~ 메소드(~){
				~ new Yy(~); --->		public Yy(~){~}		O
				~ new Yy(~); --->		protected Yy(~){~}	X
				~ new Yy(~); --->		[default] Yy(~){~}	X
				~ new Yy(~); --->		private Yy(~){~}	X
	
====================================================		
	
				a.b.c 패키지				d.e.f 패키지
				Xx 클래스				public이 안 붙은 Yy 클래스
			----------------------     ----------------------
			~ 메소드(~){
				~ new Yy(~); --->		public Yy(~){~}		X
				~ new Yy(~); --->		protected Yy(~){~}	X
				~ new Yy(~); --->		[default] Yy(~){~}	X
				~ new Yy(~); --->		private Yy(~){~}	X	
										// 수입 안 되면 호출 자체가 안 되니.
	
====================================================	

	[Xx 클래스]와 [Yy 클래스] 가 자식, 부모 관계이고, 서로 같은 패키지의 소속일 경우
	[Xx 클래스] 생성자 내부에서 [Yy 클래스]의 생성자 호출하기.
		
====================================================

	[Xx 클래스]와 [Yy 클래스] 가 서로 같은 패키지 소속일 경우
	[Xx 클래스] 내부에서 객체 생성 후 [Yy 클래스] 메소드 호출하기.
	
										동일 a.b.c 패키지
				Xx 클래스											Yy 클래스
			----------------------     						----------------------
			~ 메소드(~){
				Yy 클래스를 객체생성한 후 메소드 호출  --->	public 리턴형 메소드명(~){~}	O
				Yy 클래스를 객체생성한 후 메소드 호출  --->	protected 리턴형 메소드명(~){~}	O
				Yy 클래스를 객체생성한 후 메소드 호출  --->	[default] 리턴형 메소드명(~){~}	O
				Yy 클래스를 객체생성한 후 메소드 호출  --->	private 리턴형 메소드명(~){~}	X
				

====================================================	
	
	[Xx 클래스]와 [Yy 클래스] 가 서로 다른 패키지 소속일 경우
	[Xx 클래스] 내부에서 객체 생성 후 [Yy 클래스] 메소드 호출하기.
	
				a.b.c 패키지										d.e.f 패키지
				Xx 클래스									public 이 붙은 Yy 클래스
			----------------------     						----------------------
			~ 메소드(~){
				Yy 클래스를 객체생성한 후 메소드 호출  --->	public 리턴형 메소드명(~){~}	X
				Yy 클래스를 객체생성한 후 메소드 호출  --->	protected 리턴형 메소드명(~){~}	X
				Yy 클래스를 객체생성한 후 메소드 호출  --->	[default] 리턴형 메소드명(~){~}	X
				Yy 클래스를 객체생성한 후 메소드 호출  --->	private 리턴형 메소드명(~){~}	X
					

====================================================	

메소드 호출하기 위해선
(1)수입 가능
(2)생성자 호출 가능(찾을 수 있어야 함)
(3)메소드 호출 가능	
해야 함


메소드 왼쪽에 public 이 붙었는데 메소드 수입을 못해! 왜?
  -> 메소드를 소유하고 있는 클래스 수입을 못해 or 클래스 내부에 생성자를 못찾아~
  




====================================================
<문1> Xxx 클래스 내부에서 Yyy 클래스의 abc 라는 메소드에 public 이 붙었는데 이 메소드 호출이 실패 했다.
     호출 실패 이유를 모두 서술.
<풀>
(이유1) Yyy 클래스의 수입 실패
(이유2) Yyy 클래스의 수입은 성공 했지만, 생성자를 못 찾았음. 그래서 객체화 실패


====================================================
<문2> KBank 클래스에서  
     public void add( int money ){~}
      를 
     public void add( int money );
     
<풀> 에러 발생.
- {~} 가 없는 메소드를 소유한 클래스는 클래스 이름 앞에 abstract 를 붙여야한다.
- 즉 public abstract class KBank{ ~ } 로 선언해야한다.
- abstract 가 붙은 클래스는 new 에 의한 객체화가 불가능하다.
- {~} 가 없는 메소드 호출을 막기 위함이다.
- <참고>abstract 가 붙은 클래스를 추상 클래스라고 부른다.


====================================================
<문3>main 메소드 마지막에 다음 코딩을 삽입하면?
          System.out.println( "현재 저금 총액 => " + bank.money );
<풀>에러 발생.
- private 이 붙은 속성변수는 타 클래스에서 호출이 불가능.
- private 이 붙은 속성변수는 동료 생성자/메소드/속성변수 만이 호출 가능.


									<동일 a.b.c 패키지>
				Xx 클래스											Yy 클래스
			----------------------     						----------------------
			~ 메소드(~){
				Yy 클래스를 객체생성한 후 속성변수 호출  --->	public 자료형 속성변수(~){~}	O
				Yy 클래스를 객체생성한 후 속성변수 호출  --->	protected 자료형 속성변수(~){~}	O
				Yy 클래스를 객체생성한 후 속성변수 호출  --->	[default] 자료형 속성변수(~){~}	O
				Yy 클래스를 객체생성한 후 속성변수 호출  --->	private 자료형 속성변수(~){~}	X
				
				
	
				a.b.c 패키지										d.e.f 패키지
				Xx 클래스									public 이 붙은 Yy 클래스
			----------------------     						----------------------
			~ 메소드(~){
				Yy 클래스를 객체생성한 후 속성변수 호출  --->	public 자료형 속성변수(~){~}	O
				Yy 클래스를 객체생성한 후 속성변수 호출  --->	protected 자료형 속성변수(~){~}	X
				Yy 클래스를 객체생성한 후 속성변수 호출  --->	[default] 자료형 속성변수(~){~}	X
				Yy 클래스를 객체생성한 후 속성변수 호출  --->	private 자료형 속성변수(~){~}	X
					


				a.b.c 패키지										d.e.f 패키지
				Xx 클래스									public 이 안 붙은 Yy 클래스
			----------------------     						----------------------
			~ 메소드(~){
				Yy 클래스 객체 생성 실패 		  --->			public 자료형 속성변수(~){~}	X
				Yy 클래스 객체 생성 실패 		  --->			protected 자료형 속성변수(~){~}	X
				Yy 클래스 객체 생성 실패 		  --->			[default] 자료형 속성변수(~){~}	X
				Yy 클래스 객체 생성 실패 		  --->			private 자료형 속성변수(~){~}	X
	








  
 */
		
		
		
	}

}
