//소속 패키지 선언
package net.daum.erp;

// 하나은행 정보를 관리하는 [KBank]클래스 선언
// 이때, HBank 클래스는 Bank 클래스를 상속함.
// 상속한 클래스는 [서브클래스], 상속을 허락한 [슈퍼클래스]라고 부름.
// 서브클래스는 슈퍼클래스의 멤버를 객체 생성 없이 호출 가능.(단, private이 붙은 멤버는 호출 불가능)
public class HBank extends Bank{

	//생성자 선언
	public HBank() {
		//부모생성자 호출하기
		// 서브클래스의 생성자 첫줄에는 반드시 슈퍼클래스의 생성자를 호출하는 super(~) 가 반드시 나와야 함.
		// super(~)가 없다면 자동으로 super( )가 삽입 됨.
		super(1000, "하나"); // 없으면 은신 중!!
		
		//동료메소드 호출하기
		print_msg();
		
//	+ 자식클래스 객체화하면 생성자 호출됨
//	+ 그 클래스가 서브클래스면 생성자 첫줄은 반드시 부모클래스 생성자를 호출하도록 설계돼있음
//  +  print_msg(); 가 super(1000, "하나"); 보다 위에 있으면 에러 뜸!
//	+ 코딩을 안 하면 부모생성자중에 매개변수가 없는 기본생성자를 호출하는 코딩이 들어가더라 그 코딩이 super(); 이다.
//  + 슈퍼 생략하려면 부모클래스 중에 매개변수가 비어있는 생성자가 있어야 함.
		
	}

	//메소드 선언
	// 슈퍼클래스가 가진 print_msg 메소드를 오버라이딩(=overring = 재정의)하기.
	//  < 오버라이딩 정의 >: 슈퍼클래스의 메소드를 [재정의] 하는 것.
	//     *재정의 : 슈퍼클래스의 메소드를 복사해서 내부의 실행 구문을 바꿔 서브클래스 내부에 선언하는 행위.
	//  < 오버라이딩 규칙 >
	//    (1) 메소드명, 매개변수, 매개변수 자료형이 일치해야 함.
	//    (2) 접근제어자는 슈퍼클래스의 메소드 거 보다 범위가 크거나 같아야 함.
	//    (3) 메소드 이름 위에 @Override 라는 어노테이션을 붙이면 좋음.
	@Override
	public void print_msg() {
		System.out.println("업무시간은 오전 9:00 ~ 오후 4:00 입니다.");
	}
	
	
	
	
	
	
	
	
	
	
	
}




/*
-----------------------------------

<문1> @Override 는 무슨 표시? <입>
<풀> 어노테이션(annotation = 표기법)의 일종.
 - 어노테이션(annotation = 표기법) 정의
 : 클래스 이름 앞, 속성변수 앞, 메소드 앞, 매개변수 앞에 붙여 특정 기능을 부여하는 표기법.
 : 표기방법은 @대문자로 시작하는 영문
 : <예> @Autowired @RequestMapping 등 주로 spring 할 때 많이 등장함.
 
 @Autowired
 private Xxx aaa;

-----------------------------------

<문2> super(1000,"하나"); print_msg( ); 를
      -> print_msg( ); super(1000,"하나"); 로 바꾸면? 즉, 순서를 바꾸면?
<풀> 에러 발생.
 - 에러 발생 지점 : 클래스 HBank의 생성자 내부 super(1000,"하나");
 - 서브클래스 생성자 내부의 첫줄에 코딩은 반드시 슈퍼클래스 생성자를 호출하는 super(~); 가 나와야 함.
 - 이유는 슈퍼클래스 쪽이 먼저 초기화 돼야, 서브클래스 쪽에서 슈퍼클래스의 멤버를 호출할 수 있기 때문.
 - 부모쪽이 안전해야 자식이 편하자너~

-----------------------------------

<문3> super(1000,"하나"); 를 생략하면?
<풀> 에러 없음.
 - 서브클래스 생성자 내부의 첫줄에 super(~); 가 없으면, 자바가 super( ); 를 자동으로 넣어줌.
 - 또한, 슈퍼클래스 쪽에도 매개변수가 없는 생성자가 존재해야 함.
   --> 현재 슈퍼클래스 Bank 안에는 Bank( ) 가 있으므로 에러 발생 X.

-----------------------------------

<문4> super(1000,"하나"); 와 슈패클래스 Bank 안에 Bank( ){~} 를 생략하면?
<풀> 에러 발생.
 - 에러 발생 지점 : HBank 쪽에 public HBank() 지점
 - 서브클래스 생성자 내부의 첫줄에 super(~); 가 없으면, 자바가 super( ); 를 자동으로 넣어줌.
 - 또한, 슈퍼클래스 쪽에도 매개변수가 없는 생성자가 존재해야 함.
   --> 현재 슈퍼클래스 Bank 안에는 Bank( ) 가 없으므로 에러 발생.

-----------------------------------

<문5> 위에서 public HBank( ){ ~ } 를 주석처리 하면?
<풀> 에러 없음.
 - 생성자 코딩이 0개면 기본생성자 public 생성자명( ){ } 을 자바가 넣어줌.
   즉, 자바가 public HBank( ){ } 을 넣어줌.
 + 이 안에 슈퍼클래스의 생성자 호출하는 코딩 super( ); 가 숨어있기 때문.
 - 결국, 자바가 public HBank( ){ super( ); } 를 넣어줌.
 - But, 슈퍼클래스에는 기본생성자 Bank( ){ ~ } 가 없으니 에러 발생.

-----------------------------------

<문6> HBank 클래스에서
     public void print_msg ( ) { ~ } 를
  -> protected void print_msg ( ) { ~ }
     	또는 
  -> void print_msg ( ) { ~ }
     	또는 
  -> private void print_msg ( ) { ~ }
        로 수정하면?

<풀> 3가지 전부 에러 발생.
	//  < 오버라이딩 규칙 >
	//    (1) 메소드명, 매개변수, 매개변수 자료형이 일치해야 함.
	//    (2) 접근제어자는 슈퍼클래스의 메소드 거 보다 범위가 크거나 같아야 함.
	//    (3) 메소드 이름 위에 @Override 라는 어노테이션을 붙이면 좋음.
 - 오버라이딩 규칙 中 (2)번을 위반했기 때문.
 - 슈퍼클래스 쪽 메소드의 접근지정자가 public 이면, 오버라이딩 할 때 public 이어야 함.
 - 오버라이딩은 슈퍼클래스 쪽 메소드를 가져다가 재정의하는 것임. 즉, 확장의 의미가 있음.
 - 확장을 한다면 접근제어자도 확장 쪽으로 허락해야 하기 때문.

-----------------------------------

<문7> HBank 클래스에서 public void 
<풀> 에러 없음.
 - 생성자 안에서 동료 中, print_msg 메소드를 호출하고 있음.
 - 동료 中, 호출하고 싶은 메소드가 없으면 슈퍼클래스 쪽으로 가서 찾음.
 - 다행히도 슈퍼클래스 Bank 쪽에는 print_msg 메소드가 있어 그 놈을 호출하고 있음.


*/